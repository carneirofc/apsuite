import numpy as _np
from numpy.polynomial.polynomial import polyfit as _polyfit
import matplotlib.pyplot as _plt
from mathphys.constants import vacuum_permeability
from mathphys.beam_optics import beam_rigidity


class Wire:
    """Simulates the magnetic field of a infinite wire.
    """
    def __init__(self, position, current):
        """ Initialize a Wire object.
        Parameters
        ----------
        position : numpy.array of size 2
            Cartesian coordinates [x,y] of the wire position in [m].

        current : float, int
            Current of the wire, in units of [A].
        """
        self.position = position  # [m]
        self.current = current    # [A]

    def calc_magnetic_field(self, r):
        """Computes the magnetic field (in units of [T]) generated by the wire
        in a set of points in space.

        Parameters
        ----------
        r : numpy.array
            Array of shape (2 x N) with the coordinates [[x1, x2, ... , xN],
            [y1, y2, ... , yN]] where the field will be returned.

        Returns
        -------
        numpy.array
            Array with the same shape of r, containing the magnetic field
            components at each point in r.

        Raises
        ------
        ValueError
            If input r hasn't shape of type (2 X N).
        """
        if r.shape[0] != 2:
            raise ValueError(
                "The input position vector r must have shape of type (2, N)")
        r = r.reshape(2, -1)
        mu0 = vacuum_permeability
        r_w = self.position[:, None]  # Wire positions
        rc = r - r_w  # Cursive r
        theta = _np.arctan2(rc[1, :], rc[0, :])
        theta_vec = _np.array([-_np.sin(theta), _np.cos(theta)])
        rc_norm = _np.linalg.norm(rc, axis=0)[None, :]
        mag_field = \
            mu0 * self.current/(2*_np.pi*rc_norm)*theta_vec + r_w
        return mag_field

    @property
    def position(self):
        """."""
        return self._pos

    @position.setter
    def position(self, position):
        """."""
        position = self._check_r_size(position)
        self._pos = position

    @property
    def current(self):
        """."""
        return self._curr

    @current.setter
    def current(self, current):
        """."""
        self._curr = current

    @staticmethod
    def _check_r_size(r):
        """."""
        if r.size == 2:
            return r.ravel()
        else:
            raise ValueError('r must be a numpy array of size 2.')


class NLK:
    """Simulates the magnetic field generated by the nonlinear kicker.
    """
    def __init__(self, positions=None, current=1850):
        """Initialize a NLK object

        Parameters
        ----------
        positions : numpy.array, optional
            Array of shape (2, 8) with the wires positions [[x1, ... , xN],
            [y1, ... , yN]], by default loads the nominal wire positions.

        current : float, optional.
            Current of the wires in Amperes, by default 1850 A.
        """
        if positions is not None:
            wire_positions = positions
        else:
            wire_positions = _np.zeros([8, 2])
            s1 = _np.array([1, -1, 1, -1])
            s2 = _np.array([1, 1, -1, -1])
            for i in range(0, wire_positions.shape[0], 2):
                j = int(i/2)
                wire_positions[i] = \
                    _np.array([s1[j]*7.0,  s2[j]*5.21])[None, :]*1e-3
                wire_positions[i+1] = \
                    _np.array([s1[j]*10., s2[j]*5.85])[None, :]*1e-3

        # Creating wires
        self._wires = []
        for i in range(8):
            if i % 2:
                curr = -current
            else:
                curr = current
            pos = wire_positions[i]
            wire = Wire(pos, curr)
            self._wires.append(wire)

    @property
    def wires(self):
        """List with the Wires objects that compose the NLK.

        Returns
        -------
        list of Wires objects.
        """
        return self._wires

    @wires.setter
    def wires(self, wires_objects):
        """."""
        self._wires = wires_objects

    @property
    def positions(self):
        """Position coordinates of the wires.

        Returns
        -------
        numpy.array
            Returns a numpy.array of shape (2, 8) with the wires coordinates.
        """
        wires_positions = _np.zeros([2, 8])
        for i in range(wires_positions.shape[1]):
            wires_positions[:, [i]] = self._wires[i].position[:, None]
        return wires_positions

    @positions.setter  # Thinking in a good setter for this...
    def positions(self, wires_positions):
        for i in range(wires_positions.shape[1]):
            self._wires[i].position = wires_positions[:, i]

    @property
    def currents(self):
        """Currents of the NLK wires in [A].

        Returns
        -------
        numpy.array
            Single dimension array with the currents of each wire in NLK.
        """
        wires_currents = _np.zeros(len(self._wires))
        for i in range(len(self._wires)):
            wires_currents[i] = self._wires[i].current
        return wires_currents

    @currents.setter
    def currents(self, wires_currents):
        for i, current in enumerate(wires_currents):
            self._wires[i].current = current

    def calc_magnetic_field(self, r):
        """Computes the magnetic field generated by NLK in a set of points.

        Parameters
        ----------
        r : numpy.array
            Array of shape (2 x N) with the coordinates [[x1, x2, ... , xN],
            [y1, y2, ... , yN]] where the field will be returned.

        Returns
        -------
        numpy.array
            Array with the same shape of r, containing the magnetic field
            components in [T] at each point in r.

        Raises
        ------
        ValueError
            If the input r hasn't the shape of type (2 X N).
        """
        if r.shape[0] != 2:
            raise ValueError(
                "The input position vector r must have shape of type (2, N)")
        mag_field = _np.zeros(r.shape)
        for wire in self.wires:
            mag_field += wire.calc_magnetic_field(r)
        return mag_field

    def get_magnetic_field_on_axis(self):
        """NLK vertical field at the plane y=0 for x âˆˆ [-12, 12] mm.

        Returns
        -------
        x_space: numpy.array
            Values of x where the field was computed.

        fieldy: numpy.array
            Vertical field in [T] at y=0.
        """
        x_space = _np.linspace(-12, 12)[None, :]*1e-3
        y_space = _np.zeros(x_space.shape)
        r = _np.concatenate([x_space, y_space], axis=0)
        fieldy = self.calc_magnetic_field(r)[1, :]
        return x_space[0], fieldy

    @staticmethod
    def si_nlk_kick(
            strength=None, fit_monomials=None, plot_flag=False,
            r0=0.0):
        """Generates the NLK polynom_b, its horizontal kick and the integrated
        field at y=0. Useful for set the NLK pulse in the Sirius model.

        Parameters
        ----------
        strength : float, optional
            Multiplier of the NLK max field, by default is 1.

        fit_monomials : array like or list, optional
            The multipoles indices or degrees of the terms included in the
            polynom_b, by default is numpy.arange(10, dtype=int)

        plot_flag : bool, optional
            If True, plots the field profile, by default False.

        r0 : float, optional
            Closed orbit x coordinate, by default 0.0.

        Returns
        -------
        x : numpy.array
            Values of x where the field was computed.

        integ_field : numpy.array
            Integrated NLK field in [T.m].

        kickx : numpy.array
            Horizontal kick in [rad].

        polynom_b : numpy array of shape (fit_monomials,)
            Polynom B that describes the NLK kick.
        """

        nlk_length = 0.45
        if fit_monomials is None:
            fit_monomials = _np.arange(10, dtype=int)
        if strength is None:
            strength = 1

        nlk = NLK()
        x, mag_field = nlk.get_magnetic_field_on_axis()

        brho, *_ = beam_rigidity(energy=3)  # energy in [GeV]
        integ_field = strength * mag_field * nlk_length  # [T.m]
        kickx = integ_field / brho  # [rad]

        coeffs = _polyfit(x=x-r0, y=kickx, deg=fit_monomials)
        fit_kickx = (x[:, None]**fit_monomials[None, :]) @ coeffs
        if plot_flag:
            _plt.figure()
            _plt.scatter(1e3*(x-r0), 1e3*kickx, label="data points")
            _plt.plot(
                1e3*(x-r0), 1e3*fit_kickx, c=[0, 0.6, 0], label="fitted curve")
            _plt.xlabel('X [mm]')
            _plt.ylabel("Kick @ 3 GeV [mrad]")
            _plt.title("NLK Profile")
            _plt.legend()

        polynom_b = _np.zeros(1 + _np.max(fit_monomials))
        polynom_b[fit_monomials] = -coeffs/nlk_length
        return x, integ_field, kickx, polynom_b
